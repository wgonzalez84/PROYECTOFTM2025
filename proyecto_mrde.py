# -*- coding: utf-8 -*-
"""proyecto_MRDE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16ldrLSU3sCwkC_wK3yfvx8vPg9thSXHE

#**Modelo de recomendaci√≥n de dispositivos neuroendovasculares basado en caracter√≠sticas t√©cnicas.**

El presente Trabajo de Fin de M√°ster tiene como objetivo desarrollar un sistema inteligente de recomendaci√≥n de dispositivos neuroendovasculares, entrenado a partir de una base de datos t√©cnica propia del servicio de neurorradiolog√≠a del INCA, esta base fue realizada a travez de sus provedores mas comunmente utilizados en nuestros servicio de Neuroradiologia Intervencional. Este sistema ser√° capaz de sugerir alternativas compatibles en tiempo real ante la no disponibilidad de un dispositivo espec√≠fico, utilizando m√©tricas de similitud entre variables clave como el di√°metro interno, di√°metro externo y longitud del cat√©ter etc.

*La implementaci√≥n de esta herramienta busca aportar un valor cl√≠nico tangible, demostrando que incluso con una base de datos estructurada pero acotada ‚Äîsin necesidad de historiales cl√≠nicos extensos‚Äî es posible construir soluciones de IA aplicadas a problemas reales en el entorno hospitalario. Asimismo, se plantea como un modelo replicable y escalable a otros servicios cl√≠nicos y centros hospitalarios que enfrentan desaf√≠os similares*.

#Justificaci√≥n del Proyecto

En pabellones de alta complejidad donde se realizan procedimientos endovasculares, la selecci√≥n del dispositivo correcto impacta directamente en la seguridad, eficacia y costos del procedimiento. La gran variedad de microcat√©teres y dispositivos neurovasculares existentes, sumado a la variabilidad en la experiencia de los profesionales, vuelve cr√≠tica la sistematizaci√≥n del conocimiento t√©cnico.

*Este proyecto se justifica por la necesidad de estandarizar esa decisi√≥n y optimizar el proceso de selecci√≥n mediante una soluci√≥n tecnol√≥gica robusta, integrable con sistemas cl√≠nicos y validada en entornos reales de uso*.

##Objetivo General
El presente Trabajo de Fin de M√°ster tiene como objetivo el dise√±o e implementar un modelo predictivo basada en inteligencia artificial que recomiende dispositivos neuroendovasculares alternativos en procedimientos intervencionales, utilizando criterios de compatibilidad t√©cnica. Esta herramienta busca apoyar la toma de decisiones cl√≠nicas en tiempo real ante la no disponibilidad de ciertos insumos en el servicio de neurorradiolog√≠a del Instituto de Neurocirug√≠a de Chile, optimizando la selecci√≥n de cat√©teres, microcat√©teres y gu√≠as seg√∫n sus propiedades f√≠sicas y funcionales.
###Objetivos Espec√≠ficos

‚Ä¢	*Se desarrollo una base de datos t√©cnica de dispositivos basada en especificaciones comparables*.

‚Ä¢	*Preprocesar y normalizar los datos cl√≠nicamente relevantes*.

‚Ä¢	*Implementar una funci√≥n de recomendaci√≥n basada en distancia euclidiana*.

‚Ä¢	*Validar la precisi√≥n del modelo seg√∫n bibliografia y bases tecnicas de provedores, ejemplos como el Rebar-18 y viceversa con el Vasco+18 u otros dispositivos*.

‚Ä¢	*Explorar su integraci√≥n futura con aplicaciones m√≥viles como Smart Device*.

#Marco Te√≥rico
La inteligencia artificial aplicada al entorno cl√≠nico ha crecido de forma exponencial, especialmente en √°reas donde se requiere apoyo a la toma de decisiones. Modelos de recomendaci√≥n por similitud t√©cnica o perfiles vectorizados han demostrado ser √∫tiles en campos como farmacolog√≠a, dispositivos ortop√©dicos y recientemente, neurointervenci√≥n.

*En este contexto, el uso de t√©cnicas como MinMaxScaler para normalizaci√≥n y la m√©trica de distancia Euclidiana permiten comparar dispositivos en un espacio de caracter√≠sticas t√©cnicas con una base matem√°tica s√≥lida y explicable*.

# Estado del Arte
Seg√∫n la revisi√≥n realizada en el art√≠culo ‚ÄúAdvancing Embodied Intelligence in Robotic-Assisted Endovascular Procedures: A Systematic Review of AI Solutions‚Äù, se observa que la mayor√≠a de las aplicaciones actuales se enfocan en la asistencia rob√≥tica o planificaci√≥n vascular basada en im√°genes.
Sin embargo, existen pocas herramientas dise√±adas exclusivamente para recomendar dispositivos con base en sus dimensiones t√©cnicas como ID (inner diameter), OD (outer diameter), longitud, o compatibilidad qu√≠mica (DMSO), entre otras.

*Por ello, nuestro enfoque se sit√∫a como una innovaci√≥n espec√≠fica para la elecci√≥n de cat√©teres seg√∫n sus dimensiones en el √°mbito de la imagenolog√≠a intervencionista*.

#Metodolog√≠a y desarrollo t√©cnico

**Construcci√≥n de la base de datos**

El primer paso consisti√≥ en la sistematizaci√≥n de una propia base de datos estructurada y con informaci√≥n t√©cnica de los dispositivos disponibles en el servicio a traves de las fichas tecnicas que nos proporcionaron nuestros provedores, y a travez de la recoleccion de los datos tecnicos que proporcionan los embases de estos dispositivos que se encuentran en nuestro servicio, en gran mayoria los dispositivos que utilizamos en el servicio de neuroradiologia intervencional son licitados anualmente a traves del area encaragada de compras y abastecimiento de nuestro hospital.

La base se estructur√≥ con cat√©teres gu√≠a, microcat√©teres e intermedios, e incluy√≥ variables t√©cnicas esenciales tales como:

‚Ä¢	*Di√°metro externo (OD) en mil√≠metros, pulgadas y French (Fr)*

‚Ä¢	*Di√°metro interno (ID) en mil√≠metros, pulgadas y  French*

‚Ä¢	*Longitud del dispositivo (en cm)*

‚Ä¢	*Marca comercial y tipo de dispositivo*

‚Ä¢	*Y DMSO compatible (para desarrollo futuro)*

#L√≥gica del sistema de recomendaci√≥n

##Este principio parte de la siguiente idea cl√≠nica y l√≥gica:

**¬øQu√© es el principio de similitud t√©cnica?**

 ‚ÄúSi dos dispositivos neuroendovasculares tienen caracter√≠sticas t√©cnicas o valores muy parecidas en variables claves (por ejemplo, di√°metro interno, diametro externo, longitud y French similares), es probable que puedan usarse como alternativas o complementos en el mismo tipo de procedimiento.‚Äù Y considerarse compatibles.

"*Dispositivos neuroendovasculares que comparten caracter√≠sticas t√©cnicas similares son m√°s compatibles entre s√≠ para determinados usos cl√≠nicos*."

Para cuantificar esa similitud, empleamos una m√©trica matem√°tica muy conocida en machine learning: llamada distancia Eucl√≠dea, entre las variables t√©cnicas de los dispositivos, previa normalizaci√≥n.

**¬øQu√© es la distancia eucl√≠dea?**

Es una f√≥rmula matematica que mide la distancia "recta" entre dos puntos en un espacio multidimensional. En tu caso, cada dispositivo es un punto en un espacio definido por las variables t√©cnicas: di√°metro externo (OD), di√°metro interno (ID), longitud, medida en French (Fr), etc.

üìê F√≥rmula matem√°tica:

Para dos dispositivos con variables (x1,x2,x3)(x1,x2,x3) e (y1,y2,y3)(y1,y2,y3), la distancia eucl√≠dea d es;

‚Ä¢	d=‚àö(x1‚àíy1)2+(x2‚àíy2)2+(x3‚àíy3)2

**¬øC√≥mo ayuda la distancia eucl√≠dea?**

La distancia eucl√≠dea te da una forma cuantitativa de medir la similitud. Mientras menor sea la distancia entre dos dispositivos, m√°s similares son sus valores t√©cnicos.

Interpretaci√≥n;

‚Ä¢	*Valores m√°s bajos de distancia = dispositivos m√°s similares.*

‚Ä¢	*Si la distancia es cero, los dispositivos son id√©nticos en las variables analizadas.*

‚Ä¢	*Tu sistema permite, dado un dispositivo cl√≠nico conocido (como Rebar-18), recomendar otros con caracter√≠sticas t√©cnicas cercanas, ayudando en la elecci√≥n de materiales alternativos para procedimientos neuroendovasculares.*

####Esta l√≥gica fue implementada usando scikit-learn y numpy, con un enfoque centrado en compatibilidad estructural (lumen, di√°metro, longitud), sin requerir a√∫n, datos cl√≠nicos o anat√≥micos del paciente.

¬øPor qu√© esto es √∫til?

Tu sistema necesita diferenciar entre pares de dispositivos t√©cnicamente compatibles y no compatibles, sin intervenci√≥n humana.

‚Ä¢	*El c√°lculo de la distancia eucl√≠dea automatiza esa evaluaci√≥n.*

‚Ä¢	*Permite ordenar y recomendar los dispositivos m√°s cercanos al de referencia (por ejemplo, Rebar-18) de forma r√°pida y objetiva.*

‚Ä¢	*Esto optimiza la selecci√≥n de dispositivos alternativos en pabellones donde la disponibilidad puede cambiar.*

##Implementaci√≥n de la aplicaci√≥n

Para facilitar el uso cl√≠nico, se desarroll√≥ un modelo utilizando Google Colab, permitiendo:

‚Ä¢	Ingreso de un dispositivo que se encuentra no disponible.

‚Ä¢	Visualizaci√≥n de hasta 3 dispositivos alternativos o los primeros tres m√°s similares en orden creciente o por semaforo de color (verde= Alta similitud tecnica; amarillo=Mediana similitud tecnica ; rojo=Baja similitu tecnica).

‚Ä¢	Presentaci√≥n ordenada de los resultados seg√∫n distancia de similitud Euclediana.

La aplicaci√≥n puede ejecutarse localmente o desplegarse online mediante servicios como Google Colab, y se plantea como un m√≥dulo que en el futuro podr√≠a integrarse con sistemas cl√≠nicos como TrakCare, SAP o APP.

##Exploraci√≥n y Preprocesamiento de Datos

#Se carg√≥ la base de datos base_dispositivos_normalizada, compuesta por campos como:

‚Ä¢	*nombre*

‚Ä¢	*id_mm, od_mm, id_fr, od_fr, id_pulgadas, od_pulgadas*

‚Ä¢	*longitud_cm (con valores tipo "150/160" convertidos a 150)*

‚Ä¢	*dmso_compatible*


#Se aplicaron los siguientes pasos:

‚Ä¢	*Normalizaci√≥n de nombres de columnas.*

‚Ä¢	*Conversi√≥n de strings con coma a float (0,028 ‚Üí 0.028).*

‚Ä¢	*Imputaci√≥n o eliminaci√≥n de valores nulos (solo si existen valores nulos)*

‚Ä¢	*Conversi√≥n de longitudes con m√∫ltiplos separados por "/" al primer valor.*

¬øPor qu√© normalizamos antes?

Las variables como "Longitud" (que puede ser 130 o 170) tienen escalas mayores como (cm) que otras como "OD_mm" (0.91, por ejemplo). Eso puede afectar el c√°lculo de distancia. Y a la vez estan separados por "/" que tambien hay que normalizar.

###*Por eso normalizaremoss los datos con MinMaxScaler en nuestro colab, para que todas las variables est√©n entre 0 y 1 y todas contribuyan de forma justa al c√°lculo de similitud.*

#Paso 1. Importar y configurar librer√≠as clave:

Numpy, pandas, matplotlib y otras herramientas como scikit-learn que son esenciales para el an√°lisis de datos y construcci√≥n del modelo predictor. Al cargar todas estas bibliotecas que son necesarias para: limpieza, visualizaci√≥n, modelado, imputaci√≥n de datos faltantes (si es que los hay) y enriquecimiento de impresi√≥n en consola (gracias a rich).

El uso de rich para visualizar informaci√≥n en consola es una excelente adici√≥n para la claridad del flujo de trabajo.

Asegura que se puedan ver todas las columnas y hasta 50 filas al trabajar en Google Colab.
"""

# Usaremos rich para enriquecer la impresion por pantalla
#Importamo libreria de trabajo de cualquier proyecto de aprendizaje automatico
import numpy as np #Esta biblioteca es fundamental para las operaciones num√©ricas en Python, especialmente al trabajar con matrices y arreglos. Proporciona herramientas eficientes para c√°lculos matem√°ticos.
import seaborn as sns # se utiliza para crear gr√°ficos estad√≠sticos atractivos e informativos. Simplifica la generaci√≥n de visualizaciones complejas.
import pandas as pd # es esencial para trabajar con datos estructurados, como tablas y hojas de c√°lculo.
import numpy as np # fundamental para las operaciones num√©ricas en Python, especialmente para trabajar con matrices.
import matplotlib.pyplot as plt # biblioteca ampliamente utilizada para crear visualizaciones est√°ticas, interactivas y animadas en Python.

from rich import print # Esta biblioteca se utiliza para a√±adir texto enriquecido y un formato atractivo a la salida de la terminal.
from rich.console import Console #Esta clase se utiliza para crear un objeto de consola para un control avanzado sobre la salida de la terminal.
from rich.panel import Panel #Esta clase se utiliza para crear paneles con bordes alrededor de la salida de la terminal
from rich.syntax import Syntax #Esta clase se utiliza para resaltar c√≥digo de sintaxis en la terminal.

# Librer√≠as de Scikit-learn
from sklearn.impute import SimpleImputer # Para imputaci√≥n de valores faltantes
from sklearn.preprocessing import LabelEncoder # Para codificaci√≥n de variables categ√≥ticas
from sklearn.preprocessing import StandardScaler # Para aplicar transformaci√≥n de valores
from statsmodels.tools import add_constant  # Para agregar una columna de unos (constante) al conjunto de datos
import statsmodels.api as sm  # Para construir un modelo de regresi√≥n log√≠stica para selecci√≥n de variables
from scipy import stats  # Para realizar c√°lculos estad√≠sticos
from sklearn.linear_model import LogisticRegression # Modelo de regresi√≥n log√≠stica para ajustar los datos
from sklearn.metrics import accuracy_score, classification_report, roc_curve, roc_auc_score # M√©tricas de evaluaci√≥n del modelo
from sklearn.model_selection import cross_val_score

import matplotlib.pyplot as plt # Librer√≠a para gr√°ficas

from rich.console import Console  # Esto importa la clase Console
console = Console()              # Esto crea una instancia llamada console

# Configuracion para mostrar mas columnas y filas
pd.set_option('display.max_columns', None)
pd.set_option('display.max_rows', 50)

"""#Paso 2. Carga y exploraci√≥n de los datos:

Este bloque de c√≥digo es el punto de partida del modelo predictivo, ya que carga la base de datos con las caracter√≠sticas t√©cnicas de los dispositivos neuroendovasculares que ser√°n utilizados para hacer recomendaciones basadas en similitud.

Una vez cargado, el archivo se transform√≥ en un DataFrame de pandas que permitira la posterior limpieza, normalizaci√≥n y an√°lisis de similitud entre los dispositivos.
"""



from google.colab import files

# Solicitar al usuario que cargue un archivo
console.print("Por favor, selecciona un archivo CSV para cargar.")
uploaded = files.upload()

# El archivo cargado se almacena en un diccionario
# Obtenemos el nombre del primer (y unico) archivo cargado
file_name = list(uploaded.keys())[0]

console.print(f"[bold]Archivo cargado:[/bold] {file_name}")

df = pd.read_csv(file_name, encoding='utf-8-sig')

"""Se carg√≥ una base de datos estructurada en formato .csv que contiene las caracter√≠sticas t√©cnicas de dispositivos neuroendovasculares (di√°metro interno, externo, longitud, compatibilidad DMSO, entre otros). El archivo fue cargado utilizando la funci√≥n files.upload() desde Google Colab.

Una vez cargado, se utiliz√≥ la librer√≠a pandas para leer el archivo con pd.read_csv() y se almacen√≥ como un DataFrame.

Se inspeccionaron las primeras filas utilizando df.head(), lo cual permiti√≥ confirmar la correcta lectura del archivo y visualizar columnas clave como nombre, id_mm, od_mm, longitud_cm, id_fr, od_fr, id_pulgadas, od_pulgadas y dmso_compatible.


"""

# Importamos pandas para manejo de datos y files para cargar archivos
import pandas as pd
from google.colab import files

#Cargar archivo CSV desde tu computador
uploaded = files.upload()

# Obtener el nombre del archivo cargado
file_name = list(uploaded.keys())[0]

# Leer el archivo CSV y almacenarlo en un DataFrame llamado df
df = pd.read_csv(file_name, encoding='utf-8-sig')
df.head()  # Mostrar las primeras filas para inspecci√≥n visual

"""#Paso 3. Exploraci√≥n y Preprocesamiento de Datos

Algunas columnas como '√Ø¬ª¬ønombre' deben ser renombradas: Se elimin√≥ cualquier car√°cter especial o codificaci√≥n err√≥nea, como el s√≠mbolo '√≠' presente en algunos nombres de columnas. Esto previene errores al acceder a columnas por nombre en las etapas posteriores del an√°lisis.

Verificaci√≥n de valores nulos: Se comprob√≥ si exist√≠an celdas vac√≠as en las columnas del dataset, obteniendo como resultado cero valores faltantes, lo cual permite continuar sin aplicar imputaci√≥n.

Normalizaci√≥n de la columna longitud_cm: Algunas celdas conten√≠an m√∫ltiples valores separados por '/', como por ejemplo ‚Äú150/160‚Äù. Para efectos del modelo, se extrajo solamente el primer valor num√©rico como una representaci√≥n est√°ndar de la longitud del dispositivo. Este valor se convirti√≥ a tipo float para permitir su an√°lisis num√©rico.
"""

# Corregir nombre de columna si aparece con errores de codificaci√≥n
df.columns = [col.strip().lower().replace('√Ø¬ª¬ø', '') for col in df.columns]
print(df.columns) # Verificamos que los nombres est√©n correctos

# Corregir nombre de columna si aparece con errores de codificaci√≥n
df.columns = [col.strip().lower().replace('√Ø¬ª¬ø', '') for col in df.columns]
print(df.columns)

print(df.columns)

columnas_tecnicas = ['id_mm', 'od_pulgadas', 'od_mm', 'od_fr',
                     'id_pulgadas', 'id_fr', 'longitud_cm']

# Verificaci√≥n (opcional) de valores faltantes
print("¬øHay valores nulos?")
print(df.isna().sum()) # Resultado debe ser 0 para todas las columnas

# üìè Extraer primera longitud si hay m√∫ltiples valores separados por '/'
df['longitud_cm'] = df['longitud_cm'].astype(str).str.split('/').str[0].astype(float)

"""El dataset ahora tiene:

Nombres limpios y en min√∫scula como id_mm, od_mm, longitud_cm.

Todas las celdas completas (sin nulos).

La columna longitud_cm lista para ser procesada como n√∫mero decimal.
"""

# Corregir separadores decimales con comas en todas las columnas t√©cnicas
columnas_tecnicas = ['id_mm', 'od_pulgadas', 'od_mm', 'od_fr',
                     'id_pulgadas', 'id_fr', 'longitud_cm']

# Reemplazar comas por puntos y convertir a float
for col in columnas_tecnicas:
    df[col] = df[col].astype(str).str.replace(',', '.').astype(float)

"""#Paso 4. Normalizaci√≥n con MinMaxScaler

Se normalizaron las columnas t√©cnicas (di√°metros, longitud) para que todas est√©n en la misma escala de 0 a 1.

Algunos valores (como Longitud_cm = 150) tienen escalas muy distintas a OD_mm = 0.8, por ejemplo.

Si no normalizas, las variables con n√∫meros m√°s grandes dominar√°n el c√°lculo de distancias, falseando la similitud t√©cnica.

MinMaxScaler permite que todas las variables aporten por igual a la distancia entre dispositivos. Y me Define X antes de usarlo.
"""

# Escalar con MinMaxScaler
from sklearn.preprocessing import MinMaxScaler

# Instanciar el normalizador
scaler = MinMaxScaler()

# Aplicar la transformaci√≥n a las columnas t√©cnicas
x = scaler.fit_transform(df[columnas_tecnicas])

# Crear nuevo DataFrame con los datos normalizados
df_normalizado = pd.DataFrame(x, columns=columnas_tecnicas)

# Agregar columna 'nombre' para identificar los dispositivos
df_normalizado['nombre'] = df['nombre']

# Verificar que no haya valores nulos tras la transformaci√≥n
print(df_normalizado.isna().sum())

df_normalizado = df_normalizado.fillna(df_normalizado.mean(numeric_only=True))

from sklearn.metrics.pairwise import euclidean_distances

def recomendar_dispositivos_coloreado(nombre_dispositivo, df, columnas_tecnicas, top_n=5, considerar_dmso=None, considerar_segunda_longitud=False):
    nombre_dispositivo = nombre_dispositivo.lower()
    df_temp = df.copy()

    # Filtro por DMSO si se solicita
    if considerar_dmso is not None:
        df_temp = df_temp[df_temp['dmso_compatible'] == int(considerar_dmso)]

    # Filtro por segunda longitud (en caso de rangos tipo "115/125/132")
    if considerar_segunda_longitud:
        df_temp = df_temp[df_temp['longitud_cm'].astype(str).str.contains('/')]

    # Extraer datos t√©cnicos del dispositivo de referencia
    dispositivo_x = df_temp[df_temp['nombre'].str.lower() == nombre_dispositivo][columnas_tecnicas]

    if dispositivo_x.empty:
        print(f"[bold red]‚ö†Ô∏è Dispositivo '{nombre_dispositivo}' no encontrado o no cumple filtros.[/bold red]")
        return

    dispositivos_solo_datos = df_temp[columnas_tecnicas]
    distancias = euclidean_distances(dispositivo_x, dispositivos_solo_datos)[0]

    # Agregar la distancia al dataframe
    df_temp = df_temp.copy()
    df_temp['distancia'] = distancias

    # Excluir el dispositivo de referencia
    df_temp = df_temp[df_temp['nombre'].str.lower() != nombre_dispositivo]
    df_temp = df_temp.sort_values(by='distancia').head(top_n)

    # Visualizaci√≥n tipo sem√°foro
    console.print("[bold cyan]üîç Dispositivos similares a:[/bold cyan]", nombre_dispositivo.upper())
    for idx, row in df_temp.iterrows():
        color = "green" if row["distancia"] <= 0.05 else "yellow" if row["distancia"] <= 0.10 else "red"
        console.print(f"[{color}]üîó {row['nombre']}[/] - Distancia: {row['distancia']:.4f}")

"""#Paso 5. Recomendador basado en similitud (euclidiana)
Se calcul√≥ la distancia euclidiana entre vectores de variables t√©cnicas para encontrar los dispositivos m√°s similares:
Elegiremos un dispositivo de referencia (por ejemplo, uno espec√≠fico como "Rebar-18").

Extraemos sus caracter√≠sticas t√©cnicas y se calculara la distancia euclidiana desde ese dispositivo hacia todos los dem√°s.
"""

#Importamos la funci√≥n que permite calcular distancias eucl√≠deas entre vectores num√©ricos.
from sklearn.metrics.pairwise import euclidean_distances

# Paso 1: Elegir dispositivo de referencia (nombre debe estar en df_normalizado['nombre'])
dispositivo_referencia = "Rebar-18"

# Paso 2: Extraer el vector del dispositivo de referencia
dispositivo_x = df_normalizado[df_normalizado['nombre'] == dispositivo_referencia]

# Verificamos si el dispositivo existe
if dispositivo_x.empty:
    print(f"Dispositivo '{dispositivo_referencia}' no encontrado.")
else:
    # Paso 3: Remover columna 'nombre' para trabajar solo con variables num√©ricas
    dispositivos_solo_datos = df_normalizado.drop(columns=['nombre'])

    # Paso 4: Calcular distancias euclidianas
    distancias = euclidean_distances(dispositivo_x.drop(columns=['nombre']), dispositivos_solo_datos)

    # Paso 5: Agregar resultados al DataFrame
    df_resultado = df_normalizado.copy()
    df_resultado['distancia'] = distancias.flatten()

    # Paso 6: Ordenar por menor distancia (m√°s similar primero)
    df_resultado_ordenado = df_resultado.sort_values(by='distancia')

    # Paso 7: Mostrar los 5 m√°s similares (excepto a s√≠ mismo)
    print("Dispositivos m√°s similares a", dispositivo_referencia)
    display(df_resultado_ordenado[df_resultado_ordenado['nombre'] != dispositivo_referencia].head(8))

"""#Paso 6. Funci√≥n recomendadora con visualizaci√≥n de compatibilidad.

Se desarroll√≥ una funci√≥n reutilizable en Python que permite ingresar el nombre de un dispositivo neuroendovascular y obtener, como salida, los dispositivos m√°s similares seg√∫n su distancia euclidiana en un espacio normalizado de caracter√≠sticas t√©cnicas. Para facilitar la interpretaci√≥n, se implement√≥ un sistema tipo sem√°foro de compatibilidad t√©cnica, que clasifica los resultados como ‚ÄúAlta‚Äù, ‚ÄúMedia‚Äù o ‚ÄúBaja‚Äù compatibilidad, usando colores verde, naranjo y rojo respectivamente.

Esta clasificaci√≥n se realiza autom√°ticamente seg√∫n los cuantiles de la distribuci√≥n de distancias, de modo que los dispositivos m√°s cercanos al vector de referencia reciban color verde, y los m√°s alejados, color rojo. El resultado se presenta en una tabla HTML interactiva que facilita la exploraci√≥n visual de alternativas terap√©uticas compatibles.
"""

from sklearn.metrics.pairwise import euclidean_distances
from IPython.display import display, HTML

def recomendar_dispositivos(df_normalizado, dispositivo_referencia, columnas_tecnicas, top_n=5):
    # Verificar si el dispositivo existe
    if dispositivo_referencia not in df_normalizado['nombre'].values:
        print(f"Dispositivo '{dispositivo_referencia}' no encontrado.")
        return

    # Extraer el vector del dispositivo de referencia
    dispositivo_x = df_normalizado[df_normalizado['nombre'] == dispositivo_referencia]

    # Calcular distancias euclidianas (excepto columna nombre)
    dispositivos_solo_datos = df_normalizado.drop(columns=['nombre'])
    distancias = euclidean_distances(dispositivo_x.drop(columns=['nombre']), dispositivos_solo_datos)

    # Crear DataFrame con resultados
    df_resultado = df_normalizado.copy()
    df_resultado['distancia'] = distancias.flatten()

    # Calcular cortes de terciles (sin el propio dispositivo)
    distancias_sin_ref = df_resultado[df_resultado['nombre'] != dispositivo_referencia]['distancia']
    corte_verde = distancias_sin_ref.quantile(1/3)
    corte_amarillo = distancias_sin_ref.quantile(2/3)

    # Clasificaci√≥n tipo sem√°foro con HTML
    def clasificar_compatibilidad_color(d):
        if d <= corte_verde:
            return '<span style="color: green; font-weight: bold;">Alta</span>'
        elif d <= corte_amarillo:
            return '<span style="color: orange; font-weight: bold;">Media</span>'
        else:
            return '<span style="color: red; font-weight: bold;">Baja</span>'

    df_resultado['compatibilidad'] = df_resultado['distancia'].apply(clasificar_compatibilidad_color)

    # Ordenar por menor distancia
    df_resultado_ordenado = df_resultado.sort_values(by='distancia')

    # Mostrar tabla HTML con colores visibles
    tabla_html = df_resultado_ordenado[df_resultado_ordenado['nombre'] != dispositivo_referencia][
        ['nombre', 'distancia', 'compatibilidad'] + columnas_tecnicas].head(top_n)

    print(f"\nDispositivos m√°s similares a '{dispositivo_referencia}' (seg√∫n distancia euclidiana):")
    display(HTML(tabla_html.to_html(escape=False, index=False)))

columnas_tecnicas = ['id_mm', 'od_pulgadas', 'od_mm', 'od_fr',
                     'id_pulgadas', 'id_fr', 'longitud_cm']

# Ejecutar recomendaci√≥n para un dispositivo espec√≠fico
recomendar_dispositivos(df_normalizado, "Rebar-18", columnas_tecnicas, top_n=30)

"""##Es un gr√°fico de barras horizontales que representa la distancia euclidiana entre un dispositivo de referencia (rebar-18) y otros dispositivos neuroendovasculares, ordenados de m√°s similares a menos similares."""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from scipy.spatial.distance import cdist

# Cargar la base de datos
df = pd.read_csv('base_dispositivos_normalizada 2.0.csv')

# Asegurar que la columna 'nombre' est√© en min√∫scula y sin espacios extra
df['nombre'] = df['nombre'].str.strip().str.lower()

# Seleccionar columnas num√©ricas para la normalizaci√≥n
columnas_numericas = df.select_dtypes(include=np.number).columns
scaler = MinMaxScaler()
datos_normalizados = scaler.fit_transform(df[columnas_numericas])
df_normalizado = pd.DataFrame(datos_normalizados, columns=columnas_numericas)

# Agregar columna de nombre para referencia
df_normalizado['nombre'] = df['nombre']

# Elegir el dispositivo de referencia
dispositivo_ref = 'rebar-18'

# Verificar si existe en el DataFrame
if dispositivo_ref not in df_normalizado['nombre'].values:
    raise ValueError(f'El dispositivo "{dispositivo_ref}" no est√° en la base de datos.')

# Obtener vector del dispositivo base
dispositivo_vector = df_normalizado[df_normalizado['nombre'] == dispositivo_ref][columnas_numericas].values

# Calcular distancias euclidianas
distancias = cdist(df_normalizado[columnas_numericas], dispositivo_vector, metric='euclidean').flatten()
df_normalizado['distancia'] = distancias

# Excluir el propio dispositivo
df_resultados = df_normalizado[df_normalizado['nombre'] != dispositivo_ref]

# Obtener los 10 m√°s similares
top_10 = df_resultados.sort_values(by='distancia').head(10).copy()

# Asignar colores tipo sem√°foro seg√∫n cuartiles
cuartiles = np.quantile(top_10['distancia'], [0.33, 0.66])
def asignar_color(dist):
    if dist <= cuartiles[0]:
        return 'green'
    elif dist <= cuartiles[1]:
        return 'gold'
    else:
        return 'red'
top_10['color'] = top_10['distancia'].apply(asignar_color)

# Graficar
plt.figure(figsize=(10, 6))
bars = plt.barh(top_10['nombre'], top_10['distancia'], color=top_10['color'])
plt.xlabel('Distancia Euclidiana')
plt.title(f'Dispositivos m√°s similares a: {dispositivo_ref}')
plt.gca().invert_yaxis()
plt.grid(axis='x', linestyle='--', alpha=0.6)
plt.tight_layout()
plt.show()

"""###*¬øQu√© interpretamos del gr√°fico?*

Vasco+18 es el dispositivo m√°s similar a Rebar-18 (distancia muy baja, color verde).

Progreat 2.7 y Gama17 tambi√©n son bastante compatibles (verde).

Via 17, Eclipse 2L, Excelsior SL-10 se ubican en un nivel medio de similitud (amarillo).

XT-17, Marathon, Apollo, y Echelon 10 son los menos compatibles con rebar-18 (rojo), es decir, tienen diferencias m√°s grandes en sus caracter√≠sticas t√©cnicas.

##6.1 Funci√≥n Predictiva de Recomendaci√≥n Basada en Distancia Euclidiana

El prop√≥sito de esta funci√≥n es entregar una recomendaci√≥n de los dispositivos m√°s pr√≥ximos t√©cnicamente a uno elegido, considerando dimensiones como di√°metros internos y externos (en mm y pulgadas), longitud, y compatibilidad. Esta aproximaci√≥n permite fortalecer la toma de decisiones cl√≠nicas cuando se requiere reemplazar o buscar equivalencias a un determinado dispositivo.
"""

from sklearn.metrics.pairwise import euclidean_distances
from IPython.display import display, HTML

def mostrar_similares(dispositivo_referencia, df_base=df_normalizado, top_n=5):
    # Paso 1: Verificamos que el dispositivo exista
    if dispositivo_referencia not in df_base['nombre'].values:
        print(f"Dispositivo '{dispositivo_referencia}' no encontrado.")
        return

    # Paso 2: Separar datos t√©cnicos y vector del dispositivo de referencia
    columnas_tecnicas = ['id_mm', 'od_pulgadas', 'od_mm', 'od_fr',
                         'id_pulgadas', 'id_fr', 'longitud_cm']
    dispositivo_x = df_base[df_base['nombre'] == dispositivo_referencia]
    dispositivos_solo_datos = df_base.drop(columns=['nombre'])

    # Paso 3: Calcular distancias euclidianas
    distancias = euclidean_distances(dispositivo_x.drop(columns=['nombre']),
                                     dispositivos_solo_datos)

    # Paso 4: Guardar resultados
    df_resultado = df_base.copy()
    df_resultado['distancia'] = distancias.flatten()

    # Paso 5: Clasificar compatibilidad (sem√°foro por terciles)
    corte_verde = df_resultado['distancia'].quantile(1/3)
    corte_amarillo = df_resultado['distancia'].quantile(2/3)

    def clasificar_color(d): #Divide las distancias en terciles (bajo, medio, alto).
        if d <= corte_verde:
            return '<span style="color: green; font-weight: bold;">Alta</span>'
        elif d <= corte_amarillo:
            return '<span style="color: orange; font-weight: bold;">Media</span>'
        else:
            return '<span style="color: red; font-weight: bold;">Baja</span>'

    df_resultado['compatibilidad'] = df_resultado['distancia'].apply(clasificar_color)

    # Paso 6: Ordenar resultados y filtrar
    df_resultado_ordenado = df_resultado.sort_values(by='distancia')
    df_final = df_resultado_ordenado[df_resultado_ordenado['nombre'] != dispositivo_referencia]

    # Paso 7: Mostrar top N en formato HTML
    tabla_html = df_final[['nombre', 'distancia', 'compatibilidad']].head(top_n).to_html(escape=False, index=False)
    display(HTML(f"<h4>Dispositivos m√°s similares a <b>{dispositivo_referencia}</b>:</h4>"))
    display(HTML(tabla_html))

# Mostrar los dispositivos m√°s parecidos al 'vasco+ 18'
mostrar_similares('rebar-18')

"""# Conclusion de Utilidad y valor agregado.

###-La funci√≥n es reutilizable y acepta como entrada cualquier nombre de dispositivo presente en la base.

###-Brinda una herramienta r√°pida y visual de recomendaci√≥n basada en similitud t√©cnica.

###-Facilita la toma de decisiones cl√≠nicas con un criterio cuantitativo. Brindando una recomendaci√≥n objetiva y medible, basada en similitud matem√°tica y no solo en experiencia cl√≠nica.

###-El uso de colores tipo ‚Äúsem√°foro‚Äù facilita la interpretaci√≥n inmediata para m√©dicos, t√©cnicos e ingenieros cl√≠nicos.
"""